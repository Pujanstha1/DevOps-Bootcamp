# 10. Positional Parameters, $@, $*, and Argument Parsing with getopts

## 10.1 Positional Parameters
- `$0` → name of the script
- `$1`, `$2`, ... → first, second, etc., command-line arguments
- `$#` → number of arguments
- `$@` → all arguments as separate words
- `$*` → all arguments as a single word

### Example
```bash
#!/bin/bash
echo "Script name: $0"
echo "First argument: $1"
echo "Second argument: $2"
echo "All arguments: $@"
echo "Number of arguments: $#"
```
- Run: `./script.sh one two`
- Output:
```
Script name: ./script.sh
First argument: one
Second argument: two
All arguments: one two
Number of arguments: 2
```

---

## 10.2 Difference between $@ and $*
```bash
for arg in "$@"; do
    echo "$arg"
done

for arg in "$*"; do
    echo "$arg"
done
```
- `$@` treats each argument separately
- `$*` treats all arguments as a single string

### Example
- Script called with `./script.sh a b c`
- `$@` outputs:
```
a
b
c
```
- `$*` outputs:
```
a b c
```

---

## 10.3 Parsing Options with getopts
- `getopts` is used for **command-line option parsing**
- Handles short options like `-h` or `-f filename`

### Syntax
```bash
while getopts "hf:" opt; do
    case $opt in
        h) echo "Help message";;
        f) filename=$OPTARG;;
        *) echo "Invalid option";;
    esac
done
```
- `:` after an option means it **requires an argument**
- `$OPTARG` stores the option argument
- `$opt` stores the current option

### Example
```bash
#!/bin/bash
while getopts "u:p:h" opt; do
    case $opt in
        u) user=$OPTARG;;
        p) pass=$OPTARG;;
        h) echo "Usage: $0 -u user -p password"; exit 0;;
        *) echo "Invalid option"; exit 1;;
    esac
done

echo "User: $user, Password: $pass"
```
- Run: `./script.sh -u admin -p 1234`
- Output: `User: admin, Password: 1234`

---

## Practical Examples
1. Loop through all arguments:
```bash
for arg in "$@"; do
    echo "Argument: $arg"
done
```
2. Using getopts with optional help:
```bash
#!/bin/bash
while getopts "f:h" opt; do
    case $opt in
        f) file=$OPTARG;;
        h) echo "Usage: $0 -f filename"; exit 0;;
    esac
done
echo "Processing file: $file"
```

---

## Summary
- `$0` → script name
- `$1`, `$2`, ... → positional arguments
- `$#` → number of arguments
- `$@` vs `$*` → separate vs single string
- `getopts` → parse options in a standard way
- Proper argument handling **makes scripts user-friendly and robu