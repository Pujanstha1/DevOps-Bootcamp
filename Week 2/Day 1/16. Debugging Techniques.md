# 16. Debugging Techniques and bash -x

Debugging helps **identify and fix errors** in shell scripts.

---

## 16.1 Using bash -x
- Run a script with `bash -x script.sh` to **trace execution**
- Prints each command and its arguments as they are executed

### Example
```bash
#!/bin/bash
name="Pujan"
echo "Hello $name"
```
- Run: `bash -x script.sh`
- Output:
```
+ name=Pujan
+ echo 'Hello Pujan'
Hello Pujan
```

---

## 16.2 Using set Options for Debugging
- `set -x` → enable tracing inside script
- `set +x` → disable tracing

### Example
```bash
#!/bin/bash
set -x
count=1
echo $count
set +x
echo "Done"
```
- Only first part is traced

---

## 16.3 Using set -e and set -u
- Helps identify **unset variables** or **command failures**
```bash
#!/bin/bash
set -euo pipefail

echo $undefined_var  # Script exits due to unset variable
```

---

## 16.4 Using echo and printf for Debugging
- Insert debug statements to inspect variables and flow
```bash
x=10
y=5
sum=$((x+y))
echo "x=$x, y=$y, sum=$sum"
```
- `printf` allows formatted output
```bash
printf "x=%d, y=%d, sum=%d\n" $x $y $sum
```

---

## 16.5 Checking Exit Status
- Inspect `$?` to debug command failure
```bash
cp file1 /tmp/
if [ $? -ne 0 ]; then
    echo "Copy failed"
fi
```

---

## 16.6 Practical Examples
1. Trace script execution:
```bash
#!/bin/bash
set -x
mkdir /tmp/test_dir
cd /tmp/test_dir
set +x
```
2. Debug variable values:
```bash
#!/bin/bash
name="Alice"
age=25
echo "Debug: name=$name, age=$age"
```
3. Catch failures early:
```bash
#!/bin/bash
set -euo pipefail
rm /nonexistent/file   # Script exits immediately
```

---

## Summary
- **bash -x / set -x** → trace command execution
- **set -euo pipefail** → identify failures early
- **echo / printf** → inspect variables
- **$?** → check last command exit status
- Debugging ensures scripts **behave as expected and failu